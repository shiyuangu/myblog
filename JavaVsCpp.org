#+BLOG: wordpress
#+POSTID: 85
-----------------------
#+TITLE: Java vs. C++
#+DATE: <2014-09-01 Mon>
#+CATEGORY: Programming
-----------------------
* Exception: 
+ In Java, only subclass derived from Throwable can be thrown; in C++, any object can be thrown. 
+ Java has two type of exceptions: checked and unchecked; all exceptions in c++ are unchecked. C++ does have exception specification. But it's not part of function signature and it's not checked in complied time. At runtime, if the exception specification is not obeyed, std::unexpected is called (Cf. [[http://en.cppreference.com/w/cpp/language/except_spec][cppreference.com Exception Specification]]).

* Enum 
+ C++'s enum is just integer internally(roughly speaking) and can be mixed with integer, and hence not type safe. C++ 11 provides a type-safe enum class (cf. [[http://en.wikipedia.org/wiki/Enumerated_type#C.2B.2B][wiki-enum-c++]])
#+BEGIN_SRC cpp
enum color { red, yellow, green=20, blue };
color col = red;
int n = blue; // n == 21
#+END_SRC
+ Java's Enum is actually a special compiler-generated class rather than an arithmetic type (cf. [[http://en.wikipedia.org/wiki/Enumerated_type][Wiki-Enumerated_Type]]).  A classical usage is to use Enum for factory. For example, the follow LineSearchEnum is a factory class for creating various line search methods 
#+BEGIN_SRC java
  public enum LineSearchEnum {
    SIMPLE {
       @Override 
       public LineSearch newInstance() {
           return new SimpleLineSearch();
       }
    }, 
    ARMIJO {
      @Override
      public LineSearch newInstance() {
          return new ArmijoLineSearch();
      }
    }, 
    CUBIC {
      @Override
      public LineSearch newInstance() {
          return new CubicLineSearch();
      }
    },
    Wolfe {
        @Override
        public LineSearch newInstance() {
            return new WolfeLineSearch();
        }
    };
    public abstract LineSearch newInstance();
}
#+END_SRC
* Private inheritance 
Java doesn't support private inheritance but C++ does. Private inheritance is one way to implement the  logical relation of /"is-implemented-in-terms-of"/, for example, we can implement a set using stl::list.  The book /Effective C++/ also gives a nice example: The widget needs some functions which are already implemented in a call Timer. However, it is inappropriate for client to call Timer::onTick(). Clients of Widget should not be able to invoke anything in Timer. Widget is not a timer and the client should not be able to invoke anything in Timer directly. Public inheritance is not appropriate in this case. Private inheritance provides one possible solution. The book  /Effective C++/ provides an alternative approach of using private class and composition. This approach has two benefits: (1) The subclass of  Widget has no way to override the virtual function Timer::onTick()(note that in the first approach of private inheritance, the subclass cannot call onTick(), but can override Timer::onTick(); (2) Minimize compilation dependency if we use a pointer to WidgetTimer. 
#+BEGIN_SRC c++
  class Timer{
    pubic:
    explicit Timer(int tickFrequency);
    virtual void onTick()const;
     
  };
  class Widget:private Timer(){
   private:
    virtual void onTick() const; 
  };
  /*Alternative Approach*/
  class Widget{
    private: 
	   class WidgetTimer:public Timer{
         public: 
            virtual void onTick()const; 
       };
    WidgetTimer timer; //or use pointer WidgetTimer* timer to minimize compilation dependency; 
  };
#+END_SRC

* "Final" class and override 
 Java provides has a concept of *final* class which cannot be subclassed.  There are also *final* methods and *final* variables.  *final* methods cannot be overridden or hidden by subclasses.  Java also has an annotation of *@Override* to allow compilation to detect whether a method actually overrides anything. The keywords *final* and *override* are only introduced to C++ in C++11. They are called contextual keywords which means whether override is a keyword or not depends on the context(for example, it's valid to name a variable to be override). Also, *override* is a suffix instead of prefix. The following example is from [[http://en.cppreference.com/w/cpp/language/override][cppreference.com]]
#+BEGIN_SRC c++
struct A
{
    virtual void foo();
    void bar();
};
 
struct B : A
{
    void foo() const override; // Error: B::foo does not override A::foo
                               // (signature mismatch)
    void foo() override; // OK: B::foo overrides A::foo
    void bar() override; // Error: B::bar is not virtual
};
* "final" variables(Java) vs. const(C++)
Cf. [[http://en.wikipedia.org/wiki/Final_(Java)][wiki-final variables in Java]]. Summary 

+  Unlike the value of a constant, the value of a final variable is not necessarily known at compile time. Java's final variables must be set in initializers or constructors.
+ Java's final variables does not guarantee immutability. 

  #+BEGIN_SRC java 
      public final Position pos;
  #+END_SRC
   The pos cannot change but its members can unless it's members are final too. 
  #+BEGIN_SRC c++
       const Position & pos. 
  #+END_SRC 

* Initializers
  + Java allows initializer one-liner or blocks. Initializers are executed whenever an instance of a class is created, regardless of which constructor is used to create the instance. The following is an example [[http://www.dummies.com/how-to/content/what-is-an-initializer-in-java.html][Java Initializer]]
  #+BEGIN_SRC java
      class PrimeClass
      {
          private Scanner sc = new Scanner(System.in);
          public int x;
          {
              System.out.print("Enter the starting value for x: ");
              x = sc.nextInt();
          }
    }
    + C++ use /initialization list/ which is part of the constructors.   
  #+END_SRC
* Abstract Class vs. Interface
  Both Java and C++ have the concept of abstract class. But the concept is not quite the same. Abstract class cannot be instantiated. In c++, abstract class are the classes with pure virtual functions. C++ allows multiple inheritance and virtual inheritance. Java distinguishes /abstract class/. A class can extend at most one abstract class but implement many interface. An interface cannot have data member and all methods are public. 
* Abstract methods(Java) vs. pure virtual functions(c++)
  Atn abstract method in Java can only be public or protected, but not private. In c++, it's perfectly valid to define a private virtual function. This c++ rule seems odd at first but perfectly sensible(for example, to implement Templated Method Pattern, Cf. /Effective c++/ Item 35.  The following example compiles and runs. Note that we can even change the access control in the subclass for pure virtual function.
	#+BEGIN_SRC c++
	#include <iostream>
	using namespace std;
	class Base{
	public:
      //The following line will generate compilation error since a constructor cannot call a pure virtual function
	  //Base(){cout<<"In Base, calling Base::print()\n"; print();}
	  void testPrint(){cout<<"In Base, calling Base::print()\n"; print();}
	private:
	  virtual void print()=0;
	};
	class Derived:public Base{
	public:
	  Derived(){print();}
	  virtual void print() override {std::cout<<"In Derived::print\n";}// Note the use of keyword override 
	};
	int main(int argc, char* argv[]){
	  Derived d;
	  d.print();
	  d.testPrint();
	  return 0;
	}


	#+END_SRC
* "Protected" access control
   Both C++ and Java have "protected" access control([[http://en.cppreference.com/w/cpp/language/access][cpp access control ]], [[http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html][java access control]], [[http://stackoverflow.com/questions/902922/why-does-the-protected-modifier-in-java-allow-access-to-other-classes-in-same][why does the protected modifier in Java allow access to other classes in the same package]]), but their meaning are not the same. In C++, /protected/ members can be accessed only by the class's friends and its subclasses. In Java, /protected/ members can be access also by anyclass within the package and a subclass of its class in another package. For example, the following is a valid java. In c++, subclasses change the access control when overriding. In java, subclass can also change the access control when overriding but with restriction([[http://www.tutorialspoint.com/java/java_access_modifiers.htm][AccessControl and Inheritance]])
   #+BEGIN_SRC java 
      /*
  Base.java -- 
   */
package mine;
public abstract class Base {
	public abstract void draw();
}
/*
  HelloWorld.java -- 
   */
package mine;
public class HelloWorld {
	public static void main(String[] args){
		Derived d=new Derived();
		d.draw();
	}
}
/*
  Derived.java -- 
   */
package mine; 
public class Derived extends Base {
	@Override
	protected void draw(){
		System.out.println("In Derived::draw()-3");
	}
}

   #+END_SRC 
 
